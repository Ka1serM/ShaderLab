{"type":"data","nodes":[null,{"type":"data","data":[{"task":1},{"category":2,"type":3,"title":4,"modelPath":5,"instanceCount":6,"hints":7,"task":12,"theory":13,"starterVertexShader":14,"starterFragmentShader":15,"referenceVertexShader":16,"referenceFragmentShader":15},"Grundlagen Computergrafik","3D","Planeten System","models/Sphere.glb",10,[8,9,10,11],"Verwende gl_InstanceID, um zwischen den Planeten im Shader zu unterscheiden.","Die Reihenfolge der Matrixmultiplikation ist entscheidend: Translation * Rotation * Skalierung wendet die Skalierung zuerst an.","Um eine Hierarchie zu schaffen (z.B. Mond um Erde), multipliziere die Transformation des Kindes mit der des Elternteils: earthMatrix * moonMatrix.","Benutze den time-Uniform, um die Rotationswinkel zu animieren.","\u003Cp>Erstelle ein hierarchisches Planetensystem (Sonne, Erde, Mond) mithilfe von Instancing. Alle Transformationslogiken, wie Rotation und Translation, sollen direkt im Vertex-Shader unter Verwendung von Matrizen und dem gl_InstanceID implementiert werden.\u003C/p>\n","\u003Cp>Hierarchische Transformationen ermöglichen es, Objekte relativ zueinander zu positionieren und zu bewegen. In der Computergrafik wird dies durch die Multiplikation von Transformationsmatrizen erreicht.\u003C/p>\n\u003Cp>Ein Objekt (z.B. der Mond) kann an ein anderes Objekt (die Erde) &quot;gebunden&quot; werden, indem seine eigene lokale Transformation (Rotation und Abstand zur Erde) mit der Transformation des Elternobjekts (die Position der Erde im Sonnensystem) multipliziert wird.\u003C/p>\n\u003Cp>Die finale Transformationsmatrix für den Mond wäre also:\nfinalMoonMatrix = projectionMatrix * viewMatrix * earthMatrix * localMoonMatrix\u003C/p>\n\u003Cp>Indem wir dies für jede Instanz im Vertex-Shader tun, können wir mit einem einzigen Draw-Call ein ganzes, animiertes System rendern.\u003C/p>\n","precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nout vec3 vNormal;\nout vec3 vColor;\n\nvoid main() {\n    if (gl_InstanceID == 0) {\n        // --- Sonne ---\n\n    } else if (gl_InstanceID == 1) {\n        // --- Erde ---\n\n    } else if (gl_InstanceID == 2) {\n        // --- Mond ---\n   \n    }\n\n    vColor = vec3(1.0, 0.8, 0.2);\n    vNormal = normal;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nin vec3 vNormal;\nin vec3 vColor; // Farbe vom Vertex Shader empfangen\n\nout vec4 fragColor;\n\nvoid main() {\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0)); // world-space light\n    float diffuse = max(dot(normalize(vNormal), lightDir), 0.0);\n        \n    // Umgebungslicht, damit die dunkle Seite nicht komplett schwarz ist\n    float ambient = 0.2;\n    \n    // Farbe mit Beleuchtung kombinieren\n    vec3 finalColor = vColor * (diffuse + ambient);\n    \n    fragColor = vec4(finalColor, 1.0);\n}","precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nout vec3 vNormal;\nout vec3 vColor;\n\n// Helper functions\nmat4 translation(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n    );\n}\n\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotationY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        c, 0.0, s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvoid main() {\nmat4 modelMatrix = mat4(1.0);\n\n// Declare variables for artistic scale and orbital speed\nfloat planetScale = 0.25;  // default, overridden below\nfloat speed = 0.0;   // default, overridden below\n\nif (gl_InstanceID == 0) {\n    // Sun\n    vColor = vec3(1.0, 0.8, 0.2);\n    planetScale = 2.0;\n    modelMatrix = scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 1) {\n    // Earth\n    vColor = vec3(0.2, 0.4, 1.0);\n    planetScale = 0.7;\n    speed = 1.0;\n    modelMatrix = rotationY(time * speed) * translation(vec3(5.0, 0.0, 0.0)) * scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 2) {\n    // Moon\n    vColor = vec3(0.5, 0.5, 0.5);\n    planetScale = 0.25;\n    speed = 12.0; // fast around Earth\n    mat4 earthMatrix = rotationY(time * 1.0) * translation(vec3(5.0, 0.0, 0.0));\n    mat4 moonMatrix  = rotationY(time * speed) * translation(vec3(1.5, 0.0, 0.0)) * scale(vec3(planetScale));\n    modelMatrix = earthMatrix * moonMatrix;\n\n} else if (gl_InstanceID == 3) {\n    // Mercury\n    vColor = vec3(0.8, 0.6, 0.4);\n    planetScale = 0.3;\n    speed = 4.15;\n    modelMatrix = rotationY(time * speed) * translation(vec3(3.0, 0.0, 0.0)) * scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 4) {\n    // Venus\n    vColor = vec3(1.0, 0.7, 0.3);\n    planetScale = 0.5;\n    speed = 1.62;\n    modelMatrix = rotationY(time * speed) * translation(vec3(4.0, 0.0, 0.0)) * scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 5) {\n    // Mars\n    vColor = vec3(1.0, 0.3, 0.2);\n    planetScale = 0.5;\n    speed = 0.53;\n    modelMatrix = rotationY(time * speed) * translation(vec3(7.0, 0.0, 0.0)) * scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 6) {\n    // Jupiter\n    vColor = vec3(1.0, 0.9, 0.6);\n    planetScale = 1.5;\n    speed = 0.08;\n    modelMatrix = rotationY(time * speed) * translation(vec3(10.0, 0.0, 0.0)) * scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 7) {\n    // Saturn\n    vColor = vec3(0.9, 0.8, 0.5);\n    planetScale = 1.2;\n    speed = 0.03;\n    modelMatrix = rotationY(time * speed) * translation(vec3(13.0, 0.0, 0.0)) * scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 8) {\n    // Uranus\n    vColor = vec3(0.5, 0.9, 1.0);\n    planetScale = 1.0;\n    speed = 0.01;\n    modelMatrix = rotationY(time * speed) * translation(vec3(16.0, 0.0, 0.0)) * scale(vec3(planetScale));\n\n} else if (gl_InstanceID == 9) {\n    // Neptune\n    vColor = vec3(0.3, 0.5, 1.0);\n    planetScale = 0.95;\n    speed = 0.006;\n    modelMatrix = rotationY(time * speed) * translation(vec3(19.0, 0.0, 0.0)) * scale(vec3(planetScale));\n}\n\n// Normals\nmat3 normalMatrix = mat3(transpose(inverse(modelMatrix)));\nvNormal = normalize(normalMatrix * normal);\ngl_Position = projectionMatrix * modelViewMatrix * modelMatrix * vec4(position, 1.0);\n}"],"uses":{"params":["title"]}}]}
