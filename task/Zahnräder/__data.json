{"type":"data","nodes":[null,{"type":"data","data":[{"task":1},{"category":2,"type":3,"title":4,"modelPath":5,"instanceCount":6,"hints":7,"task":12,"theory":13,"starterVertexShader":14,"starterFragmentShader":15,"referenceVertexShader":16,"referenceFragmentShader":15},"Grundlagen Computergrafik","3D","Zahnräder","models/Gear.glb",3,[8,9,10,11],"Verwende gl_InstanceID, um zwischen den Zahnrädern im Shader zu unterscheiden.","Die Reihenfolge der Matrixmultiplikation ist entscheidend: Translation * Rotation * Skalierung wendet die Skalierung zuerst an.","Um eine Hierarchie (z. B. Zahnrad C greift in B ein) zu erzeugen, multipliziere die Transformationen der Zahnräder abhängig voneinander.","Benutze den time-Uniform, um die Rotationen zu animieren.","\u003Cp>Erstelle ein hierarchisches System aus drei Zahnrädern (A, B, C).\u003Cbr>Alle Zahnräder sollen sich um ihre jeweilige Achse drehen, und die Drehungen sollen so abgestimmt sein, dass sie korrekt ineinandergreifen.\u003Cbr>Die Transformationen werden ausschließlich im \u003Cstrong>Vertex Shader\u003C/strong> unter Verwendung von Matrizen und dem \u003Cstrong>gl_InstanceID\u003C/strong> berechnet.\u003C/p>\n","\u003Cp>Zahnräder sind ein klassisches Beispiel für gekoppelte, gegenläufige Rotationen.\u003Cbr>Wenn Zahnrad A sich im Uhrzeigersinn dreht, muss Zahnrad B sich entgegengesetzt drehen, und Zahnrad C wiederum entgegengesetzt zu B.\u003Cbr>Diese Bewegung kann durch Rotationsmatrizen im Shader simuliert werden.\u003C/p>\n\u003Cp>Die finale Matrix für jedes Zahnrad setzt sich zusammen aus: finalMatrix = projectionMatrix * viewMatrix * translation * rotation * scale\u003C/p>\n\u003Cp>Um Abhängigkeiten (z. B. Zahnrad C hängt an B) zu simulieren:\u003C/p>\n\u003Cp>finalCMatrix = projectionMatrix * viewMatrix * transformB * localCMatrix\u003C/p>\n","precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nout vec3 vNormal;\nout vec3 vColor;\n\n// Helper functions\nmat4 translation(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n    );\n}\n\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotationZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        c, -s, 0.0, 0.0,\n        s,  c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvoid main() {\n    mat4 modelMatrix = mat4(1.0);\n\n    if (gl_InstanceID == 0) {\n        // --- Zahnrad A ---\n        vColor = vec3(1.0, 0.4, 0.2); // orange\n        mat4 rotA = rotationZ(time * 0.2 * 6.2831); // 1/10 Umdrehung pro Sekunde\n        mat4 transA = translation(vec3(20.0, 10.0, 0.0));\n        modelMatrix = transA * rotA;\n\n    } else if (gl_InstanceID == 1) {\n        // --- Zahnrad B ---\n        vColor = vec3(0.2, 0.6, 1.0); // blau\n        // Zahnrad B greift in A → gegenläufige Rotation\n        mat4 rotB = rotationZ(-time * 0.4 * 6.2831);\n        mat4 transB = translation(vec3(47.0, 2.0, 0.0));\n        modelMatrix = transB * rotB;\n\n    } else if (gl_InstanceID == 2) {\n        // --- Zahnrad C ---\n        vColor = vec3(0.7, 0.8, 0.2); // gelbgrün\n        // Zahnrad C greift in B → wieder gegenläufig\n        mat4 rotC = rotationZ(time * 0.8 * 6.2831);\n        mat4 transB = translation(vec3(47.0, 2.0, 0.0));\n        mat4 rotB = rotationZ(-time * 0.4 * 6.2831);\n        mat4 transformB = transB * rotB;\n\n        mat4 localC = translation(vec3(20.0, 12.0, 0.0)) * rotC * scale(vec3(10.0, 10.0, 1.0));\n        modelMatrix = transformB * localC;\n    }\n\n    // Normals korrekt transformieren\n    mat3 normalMatrix = mat3(transpose(inverse(modelMatrix)));\n    vNormal = normalize(normalMatrix * normal);\n\n    gl_Position = projectionMatrix * modelViewMatrix * modelMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nin vec3 vNormal;\nin vec3 vColor;\n\nout vec4 fragColor;\n\nvoid main() {\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));\n    float diffuse = max(dot(normalize(vNormal), lightDir), 0.0);\n    float ambient = 0.2;\n    vec3 finalColor = vColor * (diffuse + ambient);\n    fragColor = vec4(finalColor, 1.0);\n}","precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nout vec3 vNormal;\nout vec3 vColor;\n\n// Helper functions\nmat4 translation(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n    );\n}\n\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotationX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, -s, 0.0,\n        0.0, s,  c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvoid main() {\n    mat4 modelMatrix = mat4(1.0);\n\n    // Radii for spacing\n    float radiusA = 2.0;\n    float radiusB = 1.0;\n    float radiusC = 1.5;\n\n    if (gl_InstanceID == 0) {\n        // --- Zahnrad A ---\n        vColor = vec3(1.0, 0.4, 0.2);\n        mat4 sA = scale(vec3(2.0));\n        mat4 rotA = rotationX(time * 0.2 * 6.2831);\n        mat4 transA = translation(vec3(0.0, -0.5, 0.0));\n        modelMatrix = transA * rotA * sA;\n\n    } else if (gl_InstanceID == 1) {\n        // --- Zahnrad B ---\n        vColor = vec3(0.2, 0.6, 1.0);\n        mat4 sB = scale(vec3(1.0));\n        mat4 rotB = rotationX(-time * 0.4 * 6.2831);\n        // place B right next to A\n        mat4 transB = translation(vec3(0.0, radiusA + radiusB, 0.0));\n        modelMatrix = transB * rotB * sB;\n\n    } else if (gl_InstanceID == 2) {\n        // --- Zahnrad C ---\n        vColor = vec3(0.7, 0.8, 0.2);\n        mat4 sC = scale(vec3(1.5));\n        mat4 rotC = rotationX(time * 0.6 * 6.2831);\n        // place C right next to B\n        float yB = radiusA + radiusB + 0.5;\n        float yC = yB + radiusB + radiusC; // sum distances\n        mat4 transC = translation(vec3(0.0, yC, 0.0));\n        modelMatrix = transC * rotC * sC;\n    }\n\n    // Normals korrekt transformieren\n    mat3 normalMatrix = mat3(transpose(inverse(modelMatrix)));\n    vNormal = normalize(normalMatrix * normal);\n\n    gl_Position = projectionMatrix * modelViewMatrix * modelMatrix * vec4(position, 1.0);\n}"],"uses":{"params":["title"]}}]}
