{"type":"data","nodes":[null,{"type":"data","data":[{"task":1},{"category":2,"type":3,"title":4,"modelPath":5,"hints":6,"task":11,"theory":12,"starterVertexShader":13,"starterFragmentShader":14,"referenceVertexShader":13,"referenceFragmentShader":15},"Grundlagen Computergrafik","3D","Phong","models/HeadDavid.glb",[7,8,9,10],"Transformiere die Normalen korrekt mit der `normalMatrix` für eine richtige Beleuchtung","Berechne die diffuse Komponente mit `dot(normal, lightDir)` und clamp sie mit `max()`","Berechne die specular Komponente mit `pow(max(dot(reflectDir, viewDir), 0.0), shininess)`","Addiere ambient, diffuse und specular Komponente, um die endgültige Beleuchtung zu erhalten","\u003Cp>Erstelle ein Programm, das \u003Cstrong>Phong-Beleuchtung\u003C/strong> basierend auf einer Richtungslichtquelle implementiert.  \u003C/p>\n\u003Cul>\n\u003Cli>erster Stichpunkt\u003C/li>\n\u003Cli>zweiter Stichpunkt\u003C/li>\n\u003C/ul>\n","\u003Cp>Phong-Beleuchtung ist ein Modell für diffuse und spiegelnde Beleuchtung. Die Helligkeit einer Oberfläche hängt von drei Komponenten ab:\u003C/p>\n\u003Col>\n\u003Cli>\u003Cstrong>Ambient\u003C/strong>: Grundhelligkeit der Szene\u003C/li>\n\u003Cli>\u003Cstrong>Diffuse\u003C/strong>: Helligkeit basierend auf dem Winkel zwischen Normalen und Lichtquelle\u003C/li>\n\u003Cli>\u003Cstrong>Specular\u003C/strong>: Glanzlichter basierend auf dem Winkel zwischen reflektiertem Licht und Blickrichtung\u003C/li>\n\u003C/ol>\n\u003Cp>In \u003Cstrong>GLSL\u003C/strong> werden die Normalen der Vertices über \u003Ccode>out\u003C/code>-Variablen an den Fragment-Shader weitergegeben. Diffuse und specular werden berechnet und dann mit der Basisfarbe kombiniert.\u003C/p>\n","precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec3 vNormal;\nout vec3 vPosition;\n\nvoid main() {\n    vNormal = normalize(normalMatrix * normal);\n    vPosition = vec3(modelViewMatrix * vec4(position, 1.0));\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nin vec3 vNormal;\nin vec3 vPosition;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = vec4(0.18, 0.18, 0.18, 1.0);\n}","precision highp float;\n\nin vec3 vNormal;\nin vec3 vPosition;\n\nout vec4 fragColor;\n\nvoid main() {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 viewDir = normalize(-vPosition);\n    vec3 baseColor = vec3(0.8, 0.4, 0.2);\n\n    // Diffuse component\n    float diffuse = max(dot(vNormal, lightDir), 0.0);\n\n    // Specular component\n    vec3 reflectDir = reflect(-lightDir, vNormal);\n    float specular = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n\n    // Ambient component\n    vec3 ambient = vec3(0.1);\n\n    vec3 color = ambient + baseColor * diffuse + specular * vec3(1.0);\n    fragColor = vec4(color, 1.0);\n}"],"uses":{"params":["title"]}}]}
