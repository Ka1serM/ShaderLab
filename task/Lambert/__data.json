{"type":"data","nodes":[null,{"type":"data","data":[{"task":1},{"category":2,"type":3,"title":4,"modelPath":5,"hints":6,"task":11,"theory":12,"starterVertexShader":13,"starterFragmentShader":14,"referenceVertexShader":15,"referenceFragmentShader":16},"Grundlagen Computergrafik","3D","Lambert","models/HeadDavid.glb",[7,8,9,10],"Transformiere die Normalen korrekt mit der `normalMatrix` für eine richtige Beleuchtung","Berechne den Diffusfaktor mit dot(normal, lightDir)","Klippe den Diffuswert mit max(), um negative Beleuchtung zu vermeiden","Multipliziere die Basisfarbe mit dem Diffusfaktor, um die endgültige Beleuchtung zu erhalten","\u003Cp>Erstelle ein Programm, das diffuse Beleuchtung basierend auf einer Richtungslichtquelle implementiert.  \u003C/p>\n\u003Cul>\n\u003Cli>erster Stichpunkt\u003C/li>\n\u003Cli>zweiter Stichpunkt\u003C/li>\n\u003C/ul>\n","\u003Cp>Lambert-Beleuchtung ist ein einfaches Modell für diffuse Lichtberechnung, bei dem die Helligkeit einer Oberfläche vom Winkel zwischen der \u003Cstrong>Oberflächennormalen\u003C/strong> und der \u003Cstrong>Richtung der Lichtquelle\u003C/strong> abhängt.\u003C/p>\n\u003Cp>In \u003Cstrong>GLSL\u003C/strong> werden die Normalen der Vertices über \u003Ccode>out\u003C/code>-Variablen an den Fragment-Shader weitergegeben. Der diffuse Beleuchtungsfaktor wird als \u003Cstrong>Skalarprodukt\u003C/strong> zwischen der normalisierten Normalen und der normalisierten Licht-Richtung berechnet:\u003C/p>\n","precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec3 vNormal;\n\nvoid main() {\n  // transform normal to view space and pass to fragment shader\n  vNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nin vec3 vNormal;\nout vec4 fragColor;\n\nvoid main() {\n  // simple placeholder white color\n  fragColor = vec4(0.18, 0.18, 0.18, 1.0);\n}","precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec3 vNormal;\n\nvoid main() {\n  vNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nin vec3 vNormal;\nout vec4 fragColor;\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 baseColor = vec3(0.8, 0.4, 0.2);\n  float diffuse = max(dot(vNormal, lightDir), 0.0);\n  vec3 color = baseColor * diffuse;\n  fragColor = vec4(color, 1.0);\n}"],"uses":{"params":["title"]}}]}
