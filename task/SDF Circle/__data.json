{"type":"data","nodes":[null,{"type":"data","data":[{"task":1},{"category":2,"type":3,"title":4,"modelPath":5,"hints":6,"task":11,"theory":12,"starterVertexShader":13,"starterFragmentShader":14,"referenceVertexShader":13,"referenceFragmentShader":15},"Grundlagen Computergrafik","2D","SDF Circle","models/Cube.glb",[7,8,9,10],"Berechne den Abstand von jedem Pixel zum Zentrum der Fläche","Verwende `length(position - center)` für den Abstand","Verwende `smoothstep()` für weiche Kanten","Setze die Farbe basierend auf dem Vorzeichen des Abstands","\u003Cp>Erstelle ein Fragment-Shader-Programm, das einen \u003Cstrong>Signed Distance Field (SDF) Kreis\u003C/strong> zeichnet.  \u003C/p>\n\u003Cul>\n\u003Cli>Berechne für jedes Pixel den Abstand zum Kreis-Zentrum\u003C/li>\n\u003Cli>Färbe die Pixel innerhalb des Kreises anders als die außerhalb\u003C/li>\n\u003C/ul>\n","\u003Cp>Signed Distance Fields (SDFs) speichern für jedes Pixel den \u003Cstrong>Abstand zur nächstgelegenen Oberfläche\u003C/strong>.  \u003C/p>\n\u003Cul>\n\u003Cli>Negative Werte: innerhalb des Objekts  \u003C/li>\n\u003Cli>Positive Werte: außerhalb des Objekts  \u003C/li>\n\u003Cli>Null: auf der Kontur\u003C/li>\n\u003C/ul>\n\u003Cp>Für einen Kreis: \u003Ccode>distance = length(pixelPos - center) - radius\u003C/code>.\u003Cbr>Die Farbe kann dann z.B. über \u003Ccode>smoothstep()\u003C/code> interpoliert werden, um weiche Kanten zu erzeugen.\u003C/p>\n","precision highp float;\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec2 vUV;\nout vec3 vNormal;\n\nvoid main() {\n    vUV = uv;\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvoid main() {\n    // Simple placeholder: dark gray background\n    fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n}","precision highp float;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nuniform vec2 iResolution;\n\nvoid main() {\n    // Normalize UV to -1..1 and correct for aspect ratio\n    vec2 uv = vUV * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 center = vec2(0.0, 0.0);\n    float radius = 0.5;\n\n    float dist = length(uv - center);\n\n    vec3 color = dist \u003C radius ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 0.0);\n    fragColor = vec4(color, 1.0);\n}"],"uses":{"params":["title"]}}]}
