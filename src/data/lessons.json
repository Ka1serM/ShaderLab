{
  "lessons": [
    {
      "category": "Grundlagen Computergrafik",
      "type": "2D",
      "modelPath": "models/Cube.glb",
      "title": "Bresenham",
      "hints": [
        "Nutze Ganzzahllogik, um Linienpixel zu setzen"
      ],
      "task": "Implementiere den Bresenham-Linienalgorithmus",
      "theory": "## 1. Ausgangspunkt: die ideale Linie\n\nEine Linie zwischen zwei Punkten $(x_0, y_0)$ und $(x_1, y_1)$ kann in der Steigungsform geschrieben werden:\n\n$$\ny = m \\cdot x + b\n$$\n\n- $m = \\frac{y_1 - y_0}{x_1 - x_0}$ → Steigung  \n- $b = y_0 - m \\cdot x_0$ → y-Achsenabschnitt  \n\n> Das ist die \"perfekte\" Linie in kontinuierlichen Koordinaten.\n\n---\n\n## 2. Problem: Raster / Pixel\n\nAuf einem Bildschirm oder Raster können wir **nur Pixel mit ganzzahligen Koordinaten setzen**.  \n\n- Wir müssen entscheiden, **welches Pixel in jeder Spalte gesetzt wird**, um der Linie möglichst genau zu folgen.  \n- Einfaches Runden der Gleitkommawerte ist möglich, aber **langsam**, weil es Multiplikationen und Rundungen benötigt.  \n\n---\n\n## 3. Schrittweise Annäherung\n\nBetrachte die Linie Schritt für Schritt von $x_0$ nach $x_1$:  \n\n- Aktuelles Pixel: $(x, y)$  \n- Ideale Linie: $y_\\text{ideal} = m \\cdot x + b$  \n- Wir müssen entscheiden: **y bleibt gleich oder y wird um 1 erhöht?**\n\n---\n\n## 4. Differenzen definieren\n\nWir berechnen die Differenzen:\n\n$$\n\\Delta x = x_1 - x_0, \\quad \\Delta y = y_1 - y_0\n$$\n\n- $\\Delta x$ = horizontale Länge  \n- $\\Delta y$ = vertikale Länge  \n\nDie Steigung der Linie ist $m = \\frac{\\Delta y}{\\Delta x}$.  \n\n---\n\n## 5. Fehlerbegriff\n\nWir definieren einen **Fehler**:\n\n$$\n\\text{Fehler} = y_\\text{ideal} - y_\\text{aktuell}\n$$\n\n- Wenn Fehler > 0 → die Linie liegt **über** der Pixelmitte → y muss erhöht werden.  \n- Wenn Fehler ≤ 0 → die Linie liegt **unterhalb** oder auf der Pixelmitte → y bleibt gleich.\n\n### 5.1. Problem: Gleitkomma vermeiden\n\n- Um nur mit **Ganzzahlen** zu rechnen, multiplizieren wir alles mit $\\Delta x$, um den Bruch $\\Delta y / \\Delta x$ zu eliminieren:  \n\n$$\n\\Delta x \\cdot \\text{Fehler} = \\Delta x \\cdot (y_\\text{ideal} - y_\\text{aktuell}) \n= (\\Delta y \\cdot (x - x_0) + \\Delta x \\cdot y_0) - \\Delta x \\cdot y\n$$\n\n- Definiere den **entscheidenden Ganzzahl-Fehlerterm**:\n\n$$\nD = 2 \\Delta y - \\Delta x\n$$\n\n> Durch geschicktes Multiplizieren mit $2 \\Delta y$ und $\\Delta x$ können wir **nur Ganzzahlen verwenden**, ohne Gleitkomma.\n\n---\n\n## 6. Iteration mit dem Fehlerterm\n\nFür jede Spalte $x$ (von $x_0$ bis $x_1$):\n\n1. Zeichne Pixel $(x, y)$  \n2. Prüfe den Fehlerterm $D$:  \n   - Wenn $D > 0$: Pixel in **y-Richtung erhöhen**, und Fehler anpassen: $D = D - 2 \\Delta x$  \n   - Immer: Fehler erhöhen: $D = D + 2 \\Delta y$  \n3. $x$ wird immer um 1 erhöht (oder $y$ bei steilen Linien)\n\n---\n\n## 7. Steile Linien\n\n- Wenn $|\\Delta y| > |\\Delta x|$ → Linie steiler als 45°  \n- Lösung: **x und y tauschen**, Algorithmus unverändert  \n- Vorzeichen berücksichtigen:\n\n$$\ns_x = \\text{sign}(x_1 - x_0), \\quad s_y = \\text{sign}(y_1 - y_0)\n$$\n\n- Damit funktioniert der Algorithmus in allen vier Richtungen.\n\n---\n\n## 8. Zusammenfassung\n\n- Fehlerterm $D$ misst **Abweichung der idealen Linie vom aktuellen Pixel**  \n- Entscheidung: **Pixel in y-Richtung erhöhen oder nicht**  \n- Nur Ganzzahlen → sehr effizient  \n- Ergebnis: **pixelgenaue Linie**, die der idealen Linie sehr nahekommt",
      "starterVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec2 vUV;\n\nvoid main() {\n    vUV = uv;\n    gl_Position = vec4(position, 1.0);\n}",
      "starterFragmentShader": "precision highp float;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nconst int GRID_SIZE = 32;\n\n// Draw a \"pixel\" in UV space from grid coordinates\nvoid drawPixel(int x, int y, inout vec3 color) {\n    vec2 target = vec2(float(x) / float(GRID_SIZE), float(y) / float(GRID_SIZE));\n    float threshold = 0.5 / float(GRID_SIZE); // half pixel\n    if(length(vUV - target) < threshold) {\n        color = vec3(1.0, 0.0, 0.0); // red pixel\n    }\n}\n\nvoid bresenhamLine(int x0, int y0, int x1, int y1, inout vec3 color) {\n    // Implement Bresenham integer line algorithm here\n    // Use drawPixel(x, y, color) to plot each point\n}\n\nvoid main() {\n    vec3 color = vec3(0.0); // black background\n\n    // Define line endpoints in grid coordinates\n    int x0 = int(0.05 * float(GRID_SIZE));\n    int y0 = int(0.45 * float(GRID_SIZE));\n    int x1 = int(0.95 * float(GRID_SIZE));\n    int y1 = int(0.95 * float(GRID_SIZE));\n\n    bresenhamLine(x0, y0, x1, y1, color);\n\n    fragColor = vec4(color, 1.0);\n}",
      "referenceVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec2 vUV;\n\nvoid main() {\n    vUV = uv;\n    gl_Position = vec4(position, 1.0);\n}",
      "referenceFragmentShader": "precision highp float;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nconst int GRID_SIZE = 32;\n\n// Draw a \"pixel\" in UV space from grid coordinates\nvoid drawPixel(int x, int y, inout vec3 color) {\n    vec2 target = vec2(float(x) / float(GRID_SIZE), float(y) / float(GRID_SIZE));\n    float threshold = 0.5 / float(GRID_SIZE); // half pixel\n    if(length(vUV - target) < threshold) {\n        color = vec3(1.0, 0.0, 0.0); // red pixel\n    }\n}\n\n// Bresenham line implementation\nvoid bresenhamLine(int x0, int y0, int x1, int y1, inout vec3 color) {\n    int dx = abs(x1 - x0);\n    int dy = abs(y1 - y0);\n    int sx = x0 < x1 ? 1 : -1;\n    int sy = y0 < y1 ? 1 : -1;\n\n    bool steep = dy > dx;\n    if (steep) {\n        // Swap x and y\n        int tmp;\n        tmp = x0; x0 = y0; y0 = tmp;\n        tmp = x1; x1 = y1; y1 = tmp;\n        tmp = dx; dx = dy; dy = tmp;\n        tmp = sx; sx = sy; sy = tmp;\n    }\n\n    int err = 2 * dy - dx;\n    int y = y0;\n\n    for (int i = 0; i <= dx; i++) {\n        if (steep) {\n            drawPixel(y, x0, color);\n        } else {\n            drawPixel(x0, y, color);\n        }\n\n        if (err > 0) {\n            y += sy;\n            err -= 2 * dx;\n        }\n        err += 2 * dy;\n        x0 += sx;\n    }\n}\n\nvoid main() {\n    vec3 color = vec3(0.0); // black background\n\n    // Define line endpoints in grid coordinates\n    int x0 = int(0.05 * float(GRID_SIZE));\n    int y0 = int(0.45 * float(GRID_SIZE));\n    int x1 = int(0.95 * float(GRID_SIZE));\n    int y1 = int(0.95 * float(GRID_SIZE));\n\n    // Draw the line\n    bresenhamLine(x0, y0, x1, y1, color);\n\n    fragColor = vec4(color, 1.0);\n}"
    },
    {
      "category": "Grundlagen Computergrafik",
      "type": "3D",
      "modelPath": "models/HeadDavid.glb",
      "title": "Lambert",
      "hints": [
        "Transformiere die Normalen korrekt mit der `normalMatrix` für eine richtige Beleuchtung",
        "Berechne den Diffusfaktor mit dot(normal, lightDir)",
        "Klippe den Diffuswert mit max(), um negative Beleuchtung zu vermeiden",
        "Multipliziere die Basisfarbe mit dem Diffusfaktor, um die endgültige Beleuchtung zu erhalten"
      ],
      "task": "Erstelle ein Programm, das diffuse Beleuchtung basierend auf einer Richtungslichtquelle implementiert.  \n\n- erster Stichpunkt\n- zweiter Stichpunkt",
      "theory": "Lambert-Beleuchtung ist ein einfaches Modell für diffuse Lichtberechnung, bei dem die Helligkeit einer Oberfläche vom Winkel zwischen der **Oberflächennormalen** und der **Richtung der Lichtquelle** abhängt.\n\nIn **GLSL** werden die Normalen der Vertices über `out`-Variablen an den Fragment-Shader weitergegeben. Der diffuse Beleuchtungsfaktor wird als **Skalarprodukt** zwischen der normalisierten Normalen und der normalisierten Licht-Richtung berechnet:",
      "starterVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec3 vNormal;\n\nvoid main() {\n  // transform normal to view space and pass to fragment shader\n  vNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
      "starterFragmentShader": "precision highp float;\n\nin vec3 vNormal;\nout vec4 fragColor;\n\nvoid main() {\n  // simple placeholder white color\n  fragColor = vec4(0.18, 0.18, 0.18, 1.0);\n}",
      "referenceVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec3 vNormal;\n\nvoid main() {\n  vNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
      "referenceFragmentShader": "precision highp float;\n\nin vec3 vNormal;\nout vec4 fragColor;\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 baseColor = vec3(0.8, 0.4, 0.2);\n  float diffuse = max(dot(vNormal, lightDir), 0.0);\n  vec3 color = baseColor * diffuse;\n  fragColor = vec4(color, 1.0);\n}"
    },
    {
      "category": "Grundlagen Computergrafik",
      "type": "3D",
      "modelPath": "models/HeadDavid.glb",
      "title": "Phong",
      "hints": [
        "Transformiere die Normalen korrekt mit der `normalMatrix` für eine richtige Beleuchtung",
        "Berechne die diffuse Komponente mit `dot(normal, lightDir)` und clamp sie mit `max()`",
        "Berechne die specular Komponente mit `pow(max(dot(reflectDir, viewDir), 0.0), shininess)`",
        "Addiere ambient, diffuse und specular Komponente, um die endgültige Beleuchtung zu erhalten"
      ],
      "task": "Erstelle ein Programm, das **Phong-Beleuchtung** basierend auf einer Richtungslichtquelle implementiert.  \n\n- erster Stichpunkt\n- zweiter Stichpunkt",
      "theory": "Phong-Beleuchtung ist ein Modell für diffuse und spiegelnde Beleuchtung. Die Helligkeit einer Oberfläche hängt von drei Komponenten ab:\n\n1. **Ambient**: Grundhelligkeit der Szene\n2. **Diffuse**: Helligkeit basierend auf dem Winkel zwischen Normalen und Lichtquelle\n3. **Specular**: Glanzlichter basierend auf dem Winkel zwischen reflektiertem Licht und Blickrichtung\n\nIn **GLSL** werden die Normalen der Vertices über `out`-Variablen an den Fragment-Shader weitergegeben. Diffuse und specular werden berechnet und dann mit der Basisfarbe kombiniert.",
      "starterVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec3 vNormal;\nout vec3 vPosition;\n\nvoid main() {\n    vNormal = normalize(normalMatrix * normal);\n    vPosition = vec3(modelViewMatrix * vec4(position, 1.0));\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
      "starterFragmentShader": "precision highp float;\n\nin vec3 vNormal;\nin vec3 vPosition;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = vec4(0.18, 0.18, 0.18, 1.0);\n}",
      "referenceVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec3 vNormal;\nout vec3 vPosition;\n\nvoid main() {\n    vNormal = normalize(normalMatrix * normal);\n    vPosition = vec3(modelViewMatrix * vec4(position, 1.0));\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
      "referenceFragmentShader": "precision highp float;\n\nin vec3 vNormal;\nin vec3 vPosition;\n\nout vec4 fragColor;\n\nvoid main() {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 viewDir = normalize(-vPosition);\n    vec3 baseColor = vec3(0.8, 0.4, 0.2);\n\n    // Diffuse component\n    float diffuse = max(dot(vNormal, lightDir), 0.0);\n\n    // Specular component\n    vec3 reflectDir = reflect(-lightDir, vNormal);\n    float specular = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n\n    // Ambient component\n    vec3 ambient = vec3(0.1);\n\n    vec3 color = ambient + baseColor * diffuse + specular * vec3(1.0);\n    fragColor = vec4(color, 1.0);\n}"
    },
    {
      "category": "Grundlagen Computergrafik",
      "type": "2D",
      "modelPath": "models/Cube.glb",
      "title": "SDF Circle",
      "hints": [
        "Berechne den Abstand von jedem Pixel zum Zentrum der Fläche",
        "Verwende `length(position - center)` für den Abstand",
        "Verwende `smoothstep()` für weiche Kanten",
        "Setze die Farbe basierend auf dem Vorzeichen des Abstands"
      ],
      "task": "Erstelle ein Fragment-Shader-Programm, das einen **Signed Distance Field (SDF) Kreis** zeichnet.  \n\n- Berechne für jedes Pixel den Abstand zum Kreis-Zentrum\n- Färbe die Pixel innerhalb des Kreises anders als die außerhalb",
      "theory": "Signed Distance Fields (SDFs) speichern für jedes Pixel den **Abstand zur nächstgelegenen Oberfläche**.  \n- Negative Werte: innerhalb des Objekts  \n- Positive Werte: außerhalb des Objekts  \n- Null: auf der Kontur  \n\nFür einen Kreis: `distance = length(pixelPos - center) - radius`.  \nDie Farbe kann dann z.B. über `smoothstep()` interpoliert werden, um weiche Kanten zu erzeugen.",
      "starterVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec2 vUV;\nout vec3 vNormal;\n\nvoid main() {\n    vUV = uv;\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = vec4(position, 1.0);\n}",
      "starterFragmentShader": "precision highp float;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvoid main() {\n    // Simple placeholder: dark gray background\n    fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n}",
      "referenceVertexShader": "precision highp float;\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nout vec2 vUV;\nout vec3 vNormal;\n\nvoid main() {\n    vUV = uv;\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = vec4(position, 1.0);\n}",
      "referenceFragmentShader": "precision highp float;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvoid main() {\n    vec2 center = vec2(0.5, 0.5);\n    float radius = 0.25;\n\n    float dist = length(vUV - center);\n\n    // Solid red circle\n    vec3 color = dist < radius ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 0.0);\n    fragColor = vec4(color, 1.0);\n}"
    }
  ]
}